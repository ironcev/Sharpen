using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Sharpen.Engine.Extensions.CodeDetection
{
    // TODO: Remove this class. Move the implementation to the GeneratedCodeDetector and inject it properly where needed.

    // TODO-SETTINGS: In the future we will have this in Sharpen Settings, similar to the equivalent ReSharper settings.

    /// <summary>
    /// Contains extension methods and methods related to the detection
    /// of generate code.
    /// </summary>
    internal static class GeneratedCodeDetection
    {
        private static readonly char[] Separators =
        {
            Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar, Path.VolumeSeparatorChar
        };

        public const string AutoGeneratedTag = "<auto-generated>";
        private static readonly int AutoGeneratedCommentMinLength = AutoGeneratedTag.Length + 2;

        internal static bool IsGenerated(this Document document)
        {
            return IsGeneratedFile(document.FilePath);
        }

        internal static bool IsGeneratedAssemblyInfo(this Document document)
        {
            if (string.IsNullOrWhiteSpace(document.FilePath)) return false;
            if (document.Project == null) return false;

            // Generated AssemblyInfo files have the name of the form:
            //  <ProjectName>.AssemblyInfo.cs
            // In addition, the file has to be in the obj output folder
            // but we will ignore that check at the moment.
            // It is enough to insist on the expected file name form.

            if (!document.FilePath.EndsWith(".AssemblyInfo.cs")) return false;

            int directorySeparatorIndex = document.FilePath.LastIndexOfAny(Separators);

            return string.Compare(document.Project.Name, 0, document.FilePath, directorySeparatorIndex + 1, document.Project.Name.Length, StringComparison.OrdinalIgnoreCase) == 0;
        }

        // The implementation has been adapted from Josef Pihrt's Roslynator:
        // https://github.com/JosefPihrt/Roslynator/blob/a6ed824a390831fa67e0dbb3710418239654a88e/src/CSharp/GeneratedCodeUtility.cs#L1
        public static bool IsGeneratedFile(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath)) return false;

            int directorySeparatorIndex = filePath.LastIndexOfAny(Separators);

            if (string.Compare("TemporaryGeneratedFile_", 0, filePath, directorySeparatorIndex + 1, "TemporaryGeneratedFile_".Length, StringComparison.OrdinalIgnoreCase) == 0)
                return true;

            int dotIndex = filePath.LastIndexOf(".", filePath.Length - 1, filePath.Length - directorySeparatorIndex - 1, StringComparison.Ordinal);

            if (dotIndex == -1)
                return false;

            return IsMatch(".Designer")
                   || IsMatch(".Generated")
                   || IsMatch(".g")
                   || IsMatch(".g.i")
                   || IsMatch(".AssemblyAttributes");

            bool IsMatch(string value)
            {
                int length = value.Length;

                int index = dotIndex - length;

                return index >= 0
                       && string.Compare(value, 0, filePath, index, length, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        // The implementation has been adapted from Josef Pihrt's Roslynator:
        // https://github.com/JosefPihrt/Roslynator/blob/b2c2493c880ccd06215a11fa7b42b64a1fea0470/src/CSharp/CSharp/CSharpGeneratedCodeAnalyzer.cs#L21
        internal static bool BeginsWithAutoGeneratedComment(this SyntaxTree syntaxTree)
        {
            SyntaxTriviaList leadingTrivia = syntaxTree.GetRoot().GetLeadingTrivia();

            if (!leadingTrivia.Any()) return false;

            foreach (SyntaxTrivia trivia in leadingTrivia)
            {
                if (trivia.Kind() != SyntaxKind.SingleLineCommentTrivia) continue;

                string text = trivia.ToString();

                if (text.Length >= AutoGeneratedCommentMinLength
                    && text[0] == '/'
                    && text[1] == '/')
                {
                    int index = 2;

                    while (index < text.Length
                           && char.IsWhiteSpace(text[index]))
                    {
                        index++;
                    }

                    if (string.Compare(text, index, AutoGeneratedTag, 0, AutoGeneratedTag.Length, StringComparison.OrdinalIgnoreCase) == 0)
                        return true;
                }
            }

            return false;
        }
    }
}